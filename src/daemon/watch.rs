//! Hot reload functionality using filesystem watching.
//!
//! Watches for changes to WASM modules and triggers reload events.
//! Uses the `notify` crate for cross-platform file system watching.
//! Includes debouncing to prevent duplicate events from rapid file changes.

// Allow unused - hot reload infrastructure for future development mode
#![allow(dead_code)]

use anyhow::{Context, Result};
use notify::{Config, Event, EventKind, RecommendedWatcher, RecursiveMode, Watcher};
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::sync::mpsc::{self, Receiver, Sender};
use std::time::{Duration, Instant};

/// Events generated by the file watcher.
#[derive(Debug, Clone)]
pub enum WatchEvent {
    /// A WASM module was created or modified.
    ModuleChanged { path: String },
    /// A WASM module was removed.
    ModuleRemoved { path: String },
    /// Config file (mik.toml) changed.
    ConfigChanged,
    /// An error occurred during watching.
    Error { message: String },
}

/// File watcher for hot reload functionality.
///
/// Monitors a directory for changes to `.wasm` files and config files,
/// sending events when changes are detected.
pub struct ModuleWatcher {
    _watcher: RecommendedWatcher,
    receiver: Receiver<WatchEvent>,
}

impl ModuleWatcher {
    /// Creates a new watcher for the specified modules directory.
    ///
    /// The watcher monitors for:
    /// - `.wasm` file changes (create, modify, delete)
    /// - `mik.toml` changes in the parent directory
    ///
    /// # Arguments
    ///
    /// * `modules_dir` - Path to the modules directory to watch
    /// * `config_path` - Path to the mik.toml config file
    ///
    /// # Returns
    ///
    /// A `ModuleWatcher` that can be polled for events.
    pub fn new(modules_dir: &Path, config_path: &Path) -> Result<Self> {
        let (tx, rx) = mpsc::channel();

        let modules_dir = modules_dir.to_path_buf();
        let config_path = config_path.to_path_buf();
        let sender = tx.clone();

        // Clone paths for the closure
        let modules_dir_closure = modules_dir.clone();
        let config_path_closure = config_path.clone();

        // Create debounced watcher with 500ms delay
        let config = Config::default().with_poll_interval(Duration::from_millis(500));

        let mut watcher = RecommendedWatcher::new(
            move |result: Result<Event, notify::Error>| {
                handle_notify_event(result, &modules_dir_closure, &config_path_closure, &sender);
            },
            config,
        )
        .context("Failed to create file watcher")?;

        // Watch modules directory
        watcher
            .watch(&modules_dir, RecursiveMode::Recursive)
            .with_context(|| format!("Failed to watch directory: {}", modules_dir.display()))?;

        // Watch config file's parent directory
        if let Some(config_parent) = config_path.parent() {
            watcher
                .watch(config_parent, RecursiveMode::NonRecursive)
                .with_context(|| {
                    format!(
                        "Failed to watch config directory: {}",
                        config_parent.display()
                    )
                })?;
        }

        tracing::info!(
            modules = %modules_dir.display(),
            config = %config_path.display(),
            "File watcher started"
        );

        Ok(Self {
            _watcher: watcher,
            receiver: rx,
        })
    }

    /// Tries to receive a watch event without blocking.
    ///
    /// Returns `None` if no event is available.
    pub fn try_recv(&self) -> Option<WatchEvent> {
        self.receiver.try_recv().ok()
    }

    /// Receives a watch event, blocking until one is available.
    pub fn recv(&self) -> Result<WatchEvent> {
        self.receiver
            .recv()
            .context("Watch channel closed unexpectedly")
    }

    /// Receives a watch event with timeout.
    ///
    /// Returns `None` if timeout expires before an event is received.
    pub fn recv_timeout(&self, timeout: Duration) -> Option<WatchEvent> {
        self.receiver.recv_timeout(timeout).ok()
    }
}

/// Handles raw notify events and converts them to `WatchEvents`.
fn handle_notify_event(
    result: Result<Event, notify::Error>,
    modules_dir: &Path,
    config_path: &Path,
    sender: &Sender<WatchEvent>,
) {
    match result {
        Ok(event) => {
            // Skip non-change events
            let is_change = matches!(
                event.kind,
                EventKind::Create(_) | EventKind::Modify(_) | EventKind::Remove(_)
            );

            if !is_change {
                return;
            }

            for path in &event.paths {
                // Check if it's the config file
                if path == config_path || path.file_name().is_some_and(|n| n == "mik.toml") {
                    let _ = sender.send(WatchEvent::ConfigChanged);
                    continue;
                }

                // Check if it's a WASM file in the modules directory
                let is_wasm = path.extension().is_some_and(|ext| ext == "wasm");

                let in_modules = path.starts_with(modules_dir);

                if is_wasm && in_modules {
                    let path_str = path.display().to_string();

                    let event = if matches!(event.kind, EventKind::Remove(_)) {
                        WatchEvent::ModuleRemoved { path: path_str }
                    } else {
                        WatchEvent::ModuleChanged { path: path_str }
                    };

                    let _ = sender.send(event);
                }
            }
        },
        Err(e) => {
            let _ = sender.send(WatchEvent::Error {
                message: e.to_string(),
            });
        },
    }
}

/// Default debounce duration for file events.
const DEFAULT_DEBOUNCE_MS: u64 = 300;

/// Tracks pending events for debouncing.
///
/// Events are held for a debounce period before being emitted.
/// If multiple events for the same file occur within the period,
/// only the last one is emitted.
struct DebouncedEvents {
    /// Pending events by path
    pending: HashMap<PathBuf, (WatchEvent, Instant)>,
    /// How long to wait before emitting an event
    debounce_duration: Duration,
    /// Track config changes separately (no path)
    config_pending: Option<Instant>,
}

impl DebouncedEvents {
    fn new(debounce_ms: u64) -> Self {
        Self {
            pending: HashMap::new(),
            debounce_duration: Duration::from_millis(debounce_ms),
            config_pending: None,
        }
    }

    /// Record an event for debouncing.
    fn record(&mut self, event: WatchEvent) {
        let now = Instant::now();
        match &event {
            WatchEvent::ModuleChanged { path } | WatchEvent::ModuleRemoved { path } => {
                self.pending.insert(PathBuf::from(path), (event, now));
            },
            WatchEvent::ConfigChanged => {
                self.config_pending = Some(now);
            },
            WatchEvent::Error { .. } => {
                // Errors are not debounced - record with empty path
                self.pending.insert(PathBuf::new(), (event, now));
            },
        }
    }

    /// Drain all events that have been stable for the debounce duration.
    fn drain_ready(&mut self) -> Vec<WatchEvent> {
        let now = Instant::now();
        let mut ready = Vec::new();

        // Check config event
        if let Some(time) = self.config_pending
            && now.duration_since(time) >= self.debounce_duration
        {
            ready.push(WatchEvent::ConfigChanged);
            self.config_pending = None;
        }

        // Check file events
        let expired_paths: Vec<_> = self
            .pending
            .iter()
            .filter(|(_, (_, time))| now.duration_since(*time) >= self.debounce_duration)
            .map(|(path, _)| path.clone())
            .collect();

        for path in expired_paths {
            if let Some((event, _)) = self.pending.remove(&path) {
                ready.push(event);
            }
        }

        ready
    }

    /// Returns true if there are any pending events.
    fn has_pending(&self) -> bool {
        !self.pending.is_empty() || self.config_pending.is_some()
    }
}

/// Watch loop that processes events and triggers reloads.
///
/// This function runs in a loop, watching for file changes and calling
/// the reload callback when modules change. Events are debounced to
/// prevent duplicate callbacks for rapid file changes.
///
/// # Arguments
///
/// * `modules_dir` - Path to the modules directory
/// * `config_path` - Path to mik.toml
/// * `on_reload` - Callback called when a reload is needed
pub async fn watch_loop<F>(modules_dir: &Path, config_path: &Path, mut on_reload: F) -> Result<()>
where
    F: FnMut(WatchEvent),
{
    watch_loop_with_debounce(
        modules_dir,
        config_path,
        DEFAULT_DEBOUNCE_MS,
        &mut on_reload,
    )
    .await
}

/// Watch loop with configurable debounce duration.
///
/// Same as `watch_loop` but allows customizing the debounce duration.
pub async fn watch_loop_with_debounce<F>(
    modules_dir: &Path,
    config_path: &Path,
    debounce_ms: u64,
    on_reload: &mut F,
) -> Result<()>
where
    F: FnMut(WatchEvent),
{
    let watcher = ModuleWatcher::new(modules_dir, config_path)?;
    let mut debouncer = DebouncedEvents::new(debounce_ms);

    println!(
        "[mik] Watching {}/ for changes (Ctrl+C to stop)...",
        modules_dir.display()
    );

    loop {
        // Check for shutdown signal
        tokio::select! {
            _ = tokio::signal::ctrl_c() => {
                println!("\n[mik] Stopping watch mode...");
                break;
            }
            () = tokio::time::sleep(Duration::from_millis(50)) => {
                // Collect all pending events
                while let Some(event) = watcher.try_recv() {
                    debouncer.record(event);
                }

                // Emit events that have been stable for the debounce period
                for event in debouncer.drain_ready() {
                    match &event {
                        WatchEvent::ModuleChanged { path } => {
                            let filename = Path::new(path)
                                .file_name()
                                .and_then(|n| n.to_str())
                                .unwrap_or(path);
                            println!("[mik] Detected change: {filename}");
                        }
                        WatchEvent::ModuleRemoved { path } => {
                            let filename = Path::new(path)
                                .file_name()
                                .and_then(|n| n.to_str())
                                .unwrap_or(path);
                            println!("[mik] Module removed: {filename}");
                        }
                        WatchEvent::ConfigChanged => {
                            println!("[mik] Config changed: mik.toml");
                        }
                        WatchEvent::Error { message } => {
                            eprintln!("[mik] Watch error: {message}");
                        }
                    }
                    on_reload(event);
                }
            }
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs::File;
    use std::thread;
    use tempfile::TempDir;

    #[test]
    fn test_watcher_creation() {
        let temp = TempDir::new().unwrap();
        let modules_dir = temp.path().join("modules");
        std::fs::create_dir_all(&modules_dir).unwrap();

        let config_path = temp.path().join("mik.toml");
        File::create(&config_path).unwrap();

        let watcher = ModuleWatcher::new(&modules_dir, &config_path);
        assert!(watcher.is_ok());
    }

    #[test]
    fn test_debouncer_coalesces_events() {
        let mut debouncer = DebouncedEvents::new(50); // 50ms debounce

        // Record multiple events for the same file
        debouncer.record(WatchEvent::ModuleChanged {
            path: "/test/foo.wasm".to_string(),
        });
        debouncer.record(WatchEvent::ModuleChanged {
            path: "/test/foo.wasm".to_string(),
        });
        debouncer.record(WatchEvent::ModuleChanged {
            path: "/test/foo.wasm".to_string(),
        });

        // Should not be ready yet
        let ready = debouncer.drain_ready();
        assert!(ready.is_empty());

        // Wait for debounce period
        thread::sleep(Duration::from_millis(60));

        // Now should get exactly one event
        let ready = debouncer.drain_ready();
        assert_eq!(ready.len(), 1);
        assert!(matches!(ready[0], WatchEvent::ModuleChanged { .. }));
    }

    #[test]
    fn test_debouncer_separate_files() {
        let mut debouncer = DebouncedEvents::new(50);

        // Record events for different files
        debouncer.record(WatchEvent::ModuleChanged {
            path: "/test/foo.wasm".to_string(),
        });
        debouncer.record(WatchEvent::ModuleChanged {
            path: "/test/bar.wasm".to_string(),
        });

        // Wait for debounce period
        thread::sleep(Duration::from_millis(60));

        // Should get both events
        let ready = debouncer.drain_ready();
        assert_eq!(ready.len(), 2);
    }

    #[test]
    fn test_debouncer_config_event() {
        let mut debouncer = DebouncedEvents::new(50);

        // Record multiple config events
        debouncer.record(WatchEvent::ConfigChanged);
        debouncer.record(WatchEvent::ConfigChanged);
        debouncer.record(WatchEvent::ConfigChanged);

        thread::sleep(Duration::from_millis(60));

        // Should get exactly one config event
        let ready = debouncer.drain_ready();
        assert_eq!(ready.len(), 1);
        assert!(matches!(ready[0], WatchEvent::ConfigChanged));
    }

    #[test]
    fn test_debouncer_has_pending() {
        let mut debouncer = DebouncedEvents::new(50);

        assert!(!debouncer.has_pending());

        debouncer.record(WatchEvent::ModuleChanged {
            path: "/test/foo.wasm".to_string(),
        });

        assert!(debouncer.has_pending());

        thread::sleep(Duration::from_millis(60));
        let _ = debouncer.drain_ready();

        assert!(!debouncer.has_pending());
    }
}
